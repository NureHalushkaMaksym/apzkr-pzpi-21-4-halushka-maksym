Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії

	
ПОЯСНЮВАЛЬНА ЗАПИСКА
ДО КУРСОВОЇ РОБОТИ
з дисципліни “Архітектура програмного забезпечення”
Тема роботи: “Програмна система для аналізу зон збуту їжі”



Виконав 	
ст. гр. ПЗПІ-21-4                                                                       	Галушка М.В.
Керівник: 
доц. каф. ПІ	          Лещинська І. О.

Робота захищена на оцінку                                                       _______________

Комісія:
доц. каф. ПІ	         Лещинська І. О.
доц. каф. ПІ	         Лещинський В. О.
ст. викл. каф. ПІ	         Сокорчук І. П.



Харків 2024

Аркуш завдання


Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6			____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Галушка Максим Віталійович
Тема роботи: «Програмна система для аналізу зон збуту їжі»	
Термін узгодження завдання курсової роботи «___»__________ 2024 р.
Термін здачі студентом закінченої роботи «___»___________ 2024 р.
Вихідні дані до проекту (роботи): програмна система, що включає в себе серверну частину (Back-end), клієнтську частину (Front-end), мобільний програмний застосунок, IoT або Smart Device програмний застосунок.                                                                                                 
Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма взаємодії, UML діаграма діяльності, UML діаграма компонентів.	






КАЛЕНДАРНИЙ ПЛАН


№
Назва етапу
Термін виконання 
Примітка
1
Функціональна специфікація програмного проєкту
18.02.24


2
Проєктування програмного проєкту
01.03.24


3
Кодування програмного проєкту
01.04.24


4
Оформлення програмної записки
30.05.24


5
Захист курсової роботи
08.06.24




		Дата видачі теми проєкту: «18» лютого  2024 р.

	Керівник         	                         	доц. каф. ПІ Лещинська І. О
                                                                                         (підпис)

	Студент
гр. ПЗПІ-21-4                         	   Галушка М.В.
                                                                                         (підпис)







РЕФЕРАТ 

	Пояснювальна записка до курсової роботи: 38 с., 11 рис., 3 табл., 2 додатки, 5 джерел. 
	ПРОДАЖІ, ЗОНИ ЗБУТУ, АНАЛІЗ, ТОРГІВЛЯ,  РИНОК, КЛІЄНТ. 
	Об’єктом дослідження є галузь продовольчої торгівлі, яка охоплює всі аспекти продажу продуктів харчування.
	Метою курсової роботи є розробка програмної системи для аналізу зон збуту їжі, яка дозволить зберігати та аналізувати дані про продажі, відслідковувати тенденції на ринку, забезпечувати своєчасне інформування користувачів про важливі події та покращувати ефективність роботи компанії.
	Методи розробки базуються на технології, яка включає використання фреймворка Nest.js та мови програмування TypeScript для серверної частини проекту, а також фреймворка Next.js та TypeScript для створення клієнтської частини. Мобільний застосунок реалізується на мові програмування Kotlin для ефективної взаємодії з операційною системою Android. Для реалізації IoT-частини продукту використовується Raspberry Pi з мовою програмування Node.js. База даних PostgreSQL забезпечує зберігання та опрацювання даних. Front-end та серверна частина розташовані на AWS, що гарантує масштабованість, надійність та високий рівень безпеки з використанням сертифікатів SSL та протоколів шифрування. Для забезпечення безпеки використовується TLS для захищеної передачі даних через мережу, а також механізми автентифікації та авторизації для перевірки ідентичності користувачів та контролю доступу до ресурсів.
	У результаті роботи здійснено програмну систему для аналізу зон збуту їжі. 


ЗМІСТ

Вступ……………………………………………………………………………….7  
1. Аналіз та концептуальне моделювання предметної області……………..8  1.1 Бізнес-вимоги………………………………………………………………….8 
1.1.1 Бізнес можливості………………………………………………………8 1.1.2 Бізнес-цілі та критерії успіху……………………………………………..10 
1.1.3 Потреби клієнтів або ринку……………………………………………….10 
1.1.4 Бізнес-ризики……………………………………………………………11 1.2 Концепція рішення…………………………………………………………..11
1.2.1 Окреслення концепції……………………………………………………...11 
1.2.2 Головна функціональність…………………………………………….12 1.2.3 Припущення та залежності………………………………………………..12 
1.3 Рамки та обмеження проєкту………………………………………………..13 
1.3.1 Рамки первинного випуску………………………………………………..13 
1.3.2  Рамки наступних випусків…………………………………………….15  1.3.3 Обмеження та винятки…………………………………………………….16
1.4 Бізнес-контекст………………………………………………………………16
1.4.1 Профілі зацікавлених сторін………………………………………….16  1.4.2 Пріоритети проєкту………………………………………………………..17
1.4.3 Робоче середовище…………………………………………………….18 2Постановка задачі…………………………………………………………..19  3Проектування програмного проєкту………………………………………20  3.1Проектування серверної частини проєкту…………………………...20  3.2Проектування IoT частини проєкту…………………………………..22 3.3Проектування клієнтської частини проєкту………………………….23  4Кодування програмного проєкту…………………………………………..24  4.1 Кодування серверної частини проєкту……………………………….24  4.1.1 Створення копії бази даних…………………………………………27  4.1.2 Перевірка даних при вводі на правильність…………………………..27  4.2 Кодування IoT частини проєкту………………………………………28  4.3Кодування клієнтської частини проєкту……………………………...29  Висновки…………………………………………………………………………30 Перелік джерел посилання…………………………………………………...31  Додаток А………………………………………………………………………...32 



















ВСТУП
 
	У сучасному світі, де харчова індустрія постійно зростає та еволюціонує, забезпечення адекватного аналізу ринку і розуміння попиту є критичними для успіху бізнесу в сфері громадського харчування, ресторанного бізнесу та громадського харчування загалом. Застосування застарілих методів аналізу або недостатня обробка наявних даних можуть призвести до неправильних стратегій розміщення ресторанів, втрати прибутку та низької конкурентоспроможності. 
	Метою проекту полягає у створенні програмної системи, яка забезпечить зручний і ефективний аналіз зон збуту їжі, що буде призначена для власників ресторанів, менеджерів з постачання, маркетологів та інших зацікавлених сторін, щоб надати їм можливість аналізувати дані щодо розподілу споживчого попиту на їжу у різних областях. Це допоможе їм приймати обґрунтовані рішення щодо розміщення нових ресторанів, оптимізації постачання та розвитку рекламних стратегій. 
	Програмна система для зон збуту їжі може підвищити прибутковість та забезпечити правильне розміщення ресторанів та постачання, що зменшить витрати та збільшить обсяги продажів, також швидке реагування на зміни в споживчому попиті дозволяє бути впереді конкурентів та привертати більше клієнтів.






1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ 
	1.1 Бізнес-вимоги 
	1.1.1 Бізнес-можливості

	Аналоги на ринку: 
	1. Domo: 
	Плюси: 
- Функціонал: Domo пропонує різноманітні пропонує різноманітні інструменти для збору, візуалізації та аналізу даних з різних джерел, що дозволяє користувачам отримувати повну картину свого бізнесу, також швидкий доступ до оновлених даних та інтерактивні можливості аналізу, що дозволяє користувачам реагувати на зміни в реальному часі. 
- Інтерфейс: Платформа має інтерфейс, що дозволяє користувачеві швидко навчитись працювати з нею без особливих технічних навичок. 
Мінуси: 
- Вартість: Деякі менші компанії або стартапери, які можуть не мати достатньої фінансової можливості для оплати Domo, можуть зазнати великих витрат лише на програмі. 
- Для ефективного використання Domo може знадобитися тренування персоналу, що може бути великим часом для навчання, також однієї з проблем є залежність від інтернету, що може бути проблемою в умовах нашого часу. 
	2. Tableau: 
	Плюси: 
- Tableau пропонує широкий спектр типів візуалізацій, таких як діаграми, карти, графіки та дашборди, що дозволяє створювати чіткі та зрозумілі уявлення з даних та має зручний інтерфейс, який дозволяє навіть людям без спеціальних технічних навичок легко створювати складні візуалізації. 
- Інтеграції: Tableau можна інтегрувати з різними іншими бізнес-додатками, такими як Salesforce, SAP та Microsoft Office. 
Мінуси: 
- Техпідтримка: Деякі користувачі Tableau скаржаться на те, що підтримка клієнтів може бути дуже повільною та безкорисною. 
- Залежність: Tableau доступний лише як веб-додаток, тому його не можна використовувати на мобільних пристроях це може бути проблемою, якщо потрібно мати доступ до даних та візуалізацій на ходу. 
	3. Zendesk Explore: 
	Плюси: 
- Виявлення тенденцій та прогнозування: Zendesk Explore допомагає виявити тенденції у даних про продажі, такі як сезонні коливання, популярні продукти та географічні розподіли продажів. Це може допомогти вам краще прогнозувати майбутні продажі та оптимізувати свій ланцюжок постачання. 
- Покращення обслуговування клієнтів: Zendesk Explore може допомогти відстежувати та аналізувати дані про обслуговування клієнтів, такі як 6 тикети, розмови та відгуки і це може допомогти визначити сфери, які потребують покращення, та покращити загальне задоволення клієнтів. 		Мінуси: 
- Вартість: Zendesk Explore може бути дорогим, особливо для малих та середніх підприємств. 
- Інтеграція: Програма може не інтегруватися з усіма вашими іншими системами, що може ускладнити отримання повної картини вашого бізнесу. 	Також спільним мінусом всіх систем аналогів є залежність від веб-застосунку. Усі ці програми базуються на веб-застосунках, що може створювати обмеження у доступі до даних та функціоналу з мобільних пристроїв. Веб-версії можуть бути неоптимізовані для маленьких екранів або не забезпечувати повний функціонал на мобільних платформах. 
	На відміну від конкурентів, які зосереджені лише на веб-застосунку, наша система пропонує зручний мобільний додаток з інтуїтивно зрозумілим інтерфейсом, який робить систему доступною та простою у використанні для людей з обмеженими технічними знаннями. 

	1.1.2 Бізнес-цілі та критерії успіху

	BO-1: Сформувати першу базу клієнтів, які будуть користуватися системою. 
	BO-2: Збільшення обсягів продажів через оптимізацію розміщення ресторанів. 
	BO-3: Збільшення середньоденних обсягів продажів у нових ресторанах на 20% протягом перших 6 місяців після відкриття. 
	SC-1: Збільшення кількості нових клієнтів на 25% через вдосконалення цільової аудиторії та рекламних стратегій. 
	SC-2: Зниження витрат на постачання продуктів на 10% внаслідок оптимізації логістики та укладання нових контрактів з постачальниками. 	SC-3: Відбиття грошей вкладених у впровадження нових стратегій постачання. 
	SC-4: Підвищення показника задоволеності клієнтів на 10% протягом першого року після впровадження проекту.

	1.1.3  Потреби клієнтів та ринку 

	Потреби клієнтів: 
	- зручний інтерфейс; 
	- звітність та аналітика; 
	- клієнти потребують можливості прогнозувати попит на їжу в різних географічних областях;

	1.1.4 Бізнес-ризики

	Ризики: 
	- можливість виникнення технічних проблем або збоїв у програмному забезпеченні, які можуть призвести до перебоїв у роботі системи; 
	- висока конкуренція на ринку програмного забезпечення для ресторанного бізнесу може затримати прийняття нового продукту клієнтами; 	- забезпечення конфіденційності та безпеки даних клієнтів; 
	Можливі заходи: 
	- постійне оновлення та розширення функціоналу програмної системи; 	- співпраця з іншими компаніями у сфері ресторанного бізнесу, такими як постачальники продуктів чи ресторанні мережі; 
	- забезпечення можливостей персоналізації та адаптації програмного забезпечення до конкретних потреб клієнтів ; 

	1.2 Концепція рішення 
	1.2.1 Окреслення концепції

	Головна ціль програмної системи, яку ми розробляємо, щоб вона стала невід'ємною частиною стратегічного управління ресторанним бізнесом. Ми прагнемо до того, щоб наш продукт допомагає клієнтам ефективно аналізувати ринкові тенденції, спрогнозувати попит та оптимізувати розташування своїх точок продажу. Наша програмна система буде створена з урахуванням потреб різноманітних клієнтів, від малих ресторанів до великих ресторанних мереж. Ми прагнемо до того, щоб наш продукт став незамінним інструментом для рестораторів, які прагнуть покращити ефективність свого бізнесу. Клієнти отримають більш різноманітні та якісні страви в популярних точках збуту, що позитивно вплине на їхній досвід і задоволення від їжі. 

	1.2.2 Головна функціональність

MF1. Звіти: автоматична генерація звітів та аналітика даних для відображення результатів аналізу та надання рекомендацій. 
MF2. Дані: механізм для введення даних про продажі та інші показники з точок продажу. 
MF3. Сповіщення: відправлення повідомлення користувачеві про важливі події або результати аналізу 
MF4. Профіль: призначений для власників ресторанів, менеджерів з постачання, маркетологів та інших зацікавлених сторін. 
MF5. Надання користувачеві можливості простого вибору параметрів для аналізу, таких як регіон, категорія продукту чи період часу.

	1.2.3 Припущення та залежності

П-1: Система буде гнучкою та здатною адаптуватися до змін у ринкових умовах та потреб користувачів. 
П-2: Будуть вжиті заходи для забезпечення безпеки та конфіденційності даних користувачів та бізнес-інформації. 
П-3: Клієнти мають стабільне підключення до Інтернету для користування системою. 
З-1: Залежність від доступності та ефективності технологій, що використовуються для збору. 
З-2: Система залежить від якості та достовірності даних про продажі, попит, конкурентну. 
З-3: Проекту може залежати від співпраці з постачальниками даних, які надають необхідну інформацію для аналізу зон збуту їжі. 

	1.3 Рамки та обмеження проєкту 
	1.3.1 Рамки первинного випуску

	Серверна частина має містити: 
Управління обліковим записом користувача: 
	- Створення, редагування та видалення акаунта користувача. 
	- Перегляд даних: функції для збереження, оновлення та видалення даних, що стосуються продажів та аналізу ринку. 
Сповіщення: 
	- Системи сповіщень для інформування користувачів про важливі події, такі як надходження нових даних, сповіщення про помилки або неполадки в системі. 
Адмін панель: 
	-  Керування доступом до функціональності системи. 
	- Налаштування параметрів системи та моніторинг роботи серверної частини. 
Безпека: 
	- Забезпечення безпеки даних за допомогою шифрування та авторизації користувачів. 
	- Резервне копіювання даних. 
	Функціонал IoT пристрою має містити: 
	Збір даних: 
Вимірювання та відстеження залишків продуктів на полицях або складах. Вимірювання температури у точці продажу. 
Виявлення змін у попиті на конкретні продукти або категорії продуктів. 	Front-end частина має містити: 
	Користувач: 
Реєстрація та вхід для користувачів. 
Керування обліковим записом. 
Показ даних про продажі та аналіз ринку. 
Відображення сповіщень про важливі події. 
	Адмін: 
Реєстрація та вхід адміна. 
Створення резервних копій бази даних. 
	Mobile частина має містити: 
Реєстрація та вхід користувача. 
Перегляд основних даних про продажі та попит на їжу. 
Надсилання повідомлень користувачам про важливі події або нові дані. 

	1.3.2 Рамки наступних випусків

	Серверна частина має містити: 
- Впровадження нових аналітичних алгоритмів для більш точного та швидкого аналізу ринкових тенденцій та прогнозування попиту.  
- Система персоналізованих рекомендацій для користувачів на основі аналізу їхніх вподобань. 
- Розширення функціональності моніторингу та аналітики для забезпечення більш повного контролю за роботою. 
	Функціонал IoT пристрою має містити: 
- Автоматичне налаштування продуктового асортименту відповідно до попиту на основі отриманих даних з IoT пристрою. 
- Можливість взаємодії з іншими IoT пристроями та платформами для обміну даними та розширення функціоналу. 
- Додавання можливості автоматичного налаштування параметрів роботи пристрою в залежності від зміни умов, таких як температура та вологість. 	Front-end частина має містити: 
- Підвищення швидкості роботи та адаптація інтерфейсу до різних типів мобільних пристроїв та їхніх розмірів екранів. 
- Можливість фільтрування даних за різними параметрами без перезавантаження сторінки. 
- Оновлення дизайну та розширення можливостей налаштування інтерфейсу для забезпечення більшої зручності та ефективності використання. 
	Mobile частина має містити: 
- Функції, які раніше були доступні тільки у веб-версії, забезпечити щоб користувачам був доступ до повного спектру можливостей незалежно від платформи. 
- Покращення продуктивності та ефективності роботи додатка на мобільних пристроях з різними операційними системами.

	1.3.3 Обмеження та винятки 

- робота системи може бути обмеженою через неправильне підключення IoT пристроїв; 
- система може не працювати для користувачів у випадках відсутності інтернет-підключення; 
- можливість обміну даними через соціальні мережі; 
- у першому випуску можуть бути обмежені ресурси для локалізації продукту під різні регіональні налаштування. 

	1.4 Бізнес-контекст 
	1.4.1 Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін
Зацікавлена сторона
Головна цінність
Ставлення
Головний інтерес 
Обмеження
Власники ресторанів,
магазинів
Оптимізація асортименту та стратегій збуту їжі для підвищення прибутковості
Очікування системи, яка полегшить роботу закладу та забезпечити задоволення потреб клієнтів.
Збільшення прибутків та продуктивності бізнесу. 
Доступ до інтернету та обмежений час для навчання персоналу. 
Виробники продукції
Отримання аналітичної інформації про попит на їхні продукти на різних ринках.
Отримання цінної інформації щодо попиту на їхні продукти та адаптування виробництва. 
Простий та зрозумілий застосунок, який збільшить прибутки.
Доступ до Інтернету 




Розробник
Розробити вдалий проект та заробити на ньому гроші 
Зацікавленість в успіху проекту 
Покращення якості проекту та стабільний дохід 
Нестача досвіду та бюджетні обмеження 

	
	1.4.2 Пріоритети проєкту 

	Таблиця 1.2 – Пріоритети проєкту

Показник
Виконання (етапи) 
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
План
Реліз 1.0 має бути випущеним до 10.06.2024




Функціональні сть




90% функціоналу має працювати на релізі 1.0
Якість




На релізі 1.0 має бути пройдено 100% тестів
Персонал 


Максимальний розмір команди це один розробник


Ціна




Можливе збільшення на 10% 


	
1.4.3 Робоче середовище 

Cерверна частина: 
	- Для розробки серверної частини проекту буде використано фреймворк Nest.js з використанням мови програмування TypeScript. 
Клієнтська частина: 	
	- Для створення клієнтської частини проекту буде використано фреймворк Next.js з використанням мови програмування TypeScript. 
Мобільний застосунок: 
	- Мобільний застосунок буде реалізований з використанням мови програмування Kotlin, яка забезпечує ефективну взаємодію з операційною системою Android. 
Пристрій IoT: 
	- Для реалізації IoT-частини продукту буде використано Raspberry Pi з використанням мови програмування Node.js. 
База даних: 
	- PostgreSql, яка надає різноманітні можливості для зберігання та опрацювання даних. 
Хмарні сервіси: 
	- Front-end та серверна частина будуть розташовані на AWS. Він гарантує масштабованість, надійність, високий рівень безпеки з сертифікатами SSL та протоколами шифрування. 
Забезпечення безпеки: 
TLS для захищеного передачі даних через мережу. 
Автентифікація та авторизація механізми для перевірки ідентичності користувачів та авторизації для контролю доступу до ресурсів.

2 ПОСТАНОВКА ЗАДАЧІ 

	Програмна система для аналізу зон збуту їжі покликана забезпечити ефективне управління продажами, аналіз ринкових тенденцій, а також забезпечити користувачів та адміністраторів необхідними інструментами для зручного та безпечного використання системи. 
	Користувачі можуть переглядати та редагувати свої особисті дані, відстежувати історію продажів, отримувати сповіщення, аналізувати дані про продажі та ринкові тенденції. 
	Адміністратори мають розширений контроль над системою, включаючи управління користувачами, даними про продажі, налаштуваннями системи, безпекою та резервним копіюванням. 
	Система використовує шифрування та двофакторну автентифікацію для захисту даних.













3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ 

	3.1 Проектування серверної частини проєкту
	
	Перш ніж розпочати розробку програмної системи, важливо чітко визначити та описати всі її складові частини. Для цього використовується ER-модель даних, яка візуально відображає всі сутності системи та зв'язки між ними. ER-модель даних (див. рис. Б.1 у додатку Б) була створена після детального аналізу всіх необхідних сутностей системи. Ця модель слугує основою для подальшого розробки та реалізації функціоналу системи.
1) Користувачі
id
ім'я_користувача
пароль
електронна_пошта
роль_id
2) Ролі
id
назва
3) Дозволи
id
роль_id
дозвіл
4) Продажі
id
користувач_id
назва_продукту
сума
дата_продажу
5) Аналіз ринку
id
дата_аналізу
дані
6) Сповіщення
id
користувач_id
повідомлення
створено
прочитано
7) Журнали
id
користувач_id
дія
час
8) Резервні копії
id
дата_резервного_копіювання
шлях_до_файлу
	Клієнти мають можливість переглядати та редагувати особисті дані, отримувати аналітику продажів у вигляді таблиць та графіків, а також сповіщення про важливі події. Адміністратори здійснюють керування обліковими записами, налаштовують права доступу, керують даними про продажі, генерують звіти та налаштовують параметри сповіщень. Система забезпечує візуалізацію даних у вигляді інтерактивних графіків, аналіз продажів за різними критеріями та експорт даних для подальшого використання. Заходи безпеки включають використання TLS для захисту даних та можливість двофакторної аутентифікації, а також автоматичне та ручне резервне копіювання для запобігання втратам. Система взаємодіє з іншими компонентами через REST API, що забезпечує її масштабованість та загальну структуру взаємодії.
						
	Рисунок 3.1 - UML діаграма розгортання серверної частини 
						
			Рисунок 3.2 - UML діаграма активності

3.2 Проектування IoT-частини системи 

	Функціонал IoT пристрою для системи аналізу зон збуту їжі включає збір даних про залишки продуктів на полицях або складах, вимірювання температури у точці продажу для забезпечення оптимальних умов зберігання, а також виявлення змін у попиті на конкретні продукти або категорії. Ці функції сприяють ефективному управлінню запасами, забезпечують якість продуктів та відповідають потребам споживачів.


						
	Рисунок 3.3 - UML діаграма прецедентів IoT частини системи
3.3 Проектування клієнтської частини системи 

	Для реалізації клієнтської частини системи аналізу зон збуту їжі (Front-end) необхідно врахувати наступний функціонал для користувачів і адміністраторів.
	Користувачам буде доступний функціонал для реєстрації та входу в обліковий запис. Вони зможуть керувати своїми особистими даними та налаштуваннями облікового запису. Головною функцією для користувачів буде можливість перегляду інформації про продажі у вигляді таблиць і графіків, що дозволить аналізувати ринкові тенденції. Також користувачі отримуватимуть сповіщення про важливі події, такі як нові дані про продажі або промо-акції.
	Адміністраторам буде доступна можливість реєстрації та входу в обліковий запис адміністратора. Однією з ключових функцій для адміністраторів буде створення резервних копій бази даних, що забезпечить безпеку і можливість відновлення даних в разі потреби.
	Реалізація цього функціоналу дозволить забезпечити зручний та ефективний інтерфейс для користувачів і адміністраторів системи аналізу зон збуту їжі, сприяючи зручній навігації та взаємодії з важливою інформацією.








		4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ 
	4.1 Кодування серверної частини системи 

Серверна частина системи для аналізу зон збуту їжі розроблена на основі фреймворку Nest.js з використанням TypeScript. Це забезпечує ефективність, сучасність та зручність розробки.
Файл main.ts:
Створення та запуск додатку Nest.js.
Налаштування Swagger для автоматичної генерації документації API.
Встановлення Swagger UI для доступу до документації.
Запуск додатку на певному порту.
Файл app.module.ts:
Імпорт та налаштування модулів Nest.js.
Підключення до PostgreSQL бази даних.
Реєстрація модулів для контролерів та сервісів.
Визначення основних сутностей системи.
Переваги використання TypeScript та Nest.js:
Покращена читабельність та зрозумілість коду.
Масштабованість та простота розширення функціональності.
Підвищена безпека та надійність коду.
	Ці два файли є основою серверної частини системи, забезпечуючи її ефективну роботу та зручність розробки.
	Специфікація REST API та функцій які взаємодіють з веб-сервісами наведена нижче в таблиці 4.1


Таблиця 4.1 - Специфікація REST API серверної частини системи 
Сутність
Метод
Посилання
Дія
Користувач
GET
/api/users/{id}
Отримати інформацію про користувача за ID
POST
/api/users
Створити нового користувача
PUT
/api/users/{id}
Оновити інформацію про користувача за ID
DELETE
/api/users/{id}
Видалити користувача за ID
Роль
GET
/api/roles/{id}
Отримати інформацію про роль за ID
POST
/api/roles
Створити нову роль
PUT
/api/roles/{id}
Оновити інформацію про роль за ID
DELETE
/api/roles/{id}
Видалити роль за ID
Дозволи
GET
/api/permissions/{id}
Отримати інформацію про дозвіл за ID
POST
/api/permissions
Створити новий дозвіл
PUT
/api/permissions/{id}
Оновити інформацію про дозвіл за ID
DELETE
/api/permissions/{id}
Видалити дозвіл за ID
Продажі
GET
/api/sales/{id}
Отримати інформацію про продаж за ID
POST
/api/sales
Створити новий запис про продаж
PUT
/api/sales/{id}
Оновити інформацію про продаж за ID
DELETE
/api/sales/{id}
Видалити запис про продаж за ID
Сповіщення
GET
/api/notifications/{id}
Отримати інформацію про сповіщення за ID
POST
/api/notifications
Створити нове сповіщення
PUT
/api/notifications/{id}
Оновити інформацію про сповіщення за ID
DELETE
/api/notifications/{id}
Видалити сповіщення за ID
Резервні копії
GET
/api/backups/{id}
Отримати інформацію про резервну копію за ID


POST
/api/backups
Створити нову резервну копію


PUT
/api/backups/{id}
Оновити інформацію про резервну копію за ID


DELETE
/api/backups/{id}
Видалити резервну копію за ID




	4.1.1 Створення копії бази даних
	Сутність Backup описується класом, який використовує декоратори TypeORM для визначення взаємозв'язків і полів таблиці бази даних. Ця сутність містить ідентифікатор копії (id), дату створення резервної копії (backup_date) і шлях до файлу (file_path), де зберігається копія даних.
	Сервіс BackupsService надає методи для виконання операцій з копіями даних: знаходження всіх копій (findAll), знаходження конкретної копії за її ідентифікатором (findOne), створення нової копії (create), оновлення існуючої копії (update) і видалення копії (remove). Ці методи використовують репозиторій TypeORM для взаємодії з базою даних і забезпечують CRUD операції з копіями.
	Контролер BackupsController містить обробники запитів для HTTP маршрутів, які дозволяють клієнтам взаємодіяти з резервними копіями через REST API. Ці обробники викликають відповідні методи сервісу для обробки запитів користувачів.
	Модуль BackupsModule інтегрує сервіси і контролери, пов'язані з копіями даних, у вашому головному модулі AppModule. Це забезпечує необхідність компоненти для роботи з резервними копіями бази даних у вашій системі, що є важливим аспектом для забезпечення безпеки і готовності до відновлення даних.

4.1.2 Перевірка даних при вводі на правильність

	У проекті процес перевірки даних на правильність передбачає використання декораторів та типів даних у сутностях, які визначають обмеження для полів, таких як максимальна довжина рядка або обов'язковість полів. Відповідні сервіси мають методи для збереження та оновлення даних, які включають в себе валідацію переданої інформації, щоб забезпечити її відповідність обмеженням і очікуванням. Контролери обробляють HTTP-запити і виконують базову перевірку формату даних перед передачею інформації до відповідних сервісів для подальшої обробки.

	4.2 Кодування IoT-частини системи

	На Raspberry Pi успішно встановлено Node.js, що гарантує оптимальну сумісність і продуктивність програмного забезпечення. Для розробки IoT-частини системи були написані скрипти на Node.js, які взаємодіють з підключеними сенсорами та датчиками на Raspberry Pi. Ці скрипти використовуються для збору різних типів даних, необхідних для подальшої аналітики та моніторингу у контексті аналізу зон збуту їжі.
	Для аналізу змін у попиті на конкретні продукти або категорії використовано алгоритми машинного навчання. Це дозволяє системі автоматично виявляти та реагувати на зміни в споживчих тенденціях, що забезпечує більш ефективне управління запасами і стратегії маркетингу.
	Щодо взаємодії з серверною частиною системи через REST API, реалізовано відправку даних до сервера через запити POST. Це включає дані про залишки продуктів і температуру, що надсилаються для подальшого аналізу і зберігання на сервері. Також налаштовано обмін командами через запити GET для отримання інструкцій від сервера, наприклад, для активації певних дій або налаштувань в залежності від аналізу отриманих даних.

		Рисунок 3.1 - UML діаграма пакетів для IoT частини системи

	4.3 Кодування веб-клієнту частини

	Для реалізації клієнтської частини проекту використовується фреймворк Next.js разом з мовою програмування TypeScript. Next.js є платформою для розробки веб-додатків, яка підтримує серверний рендерінг (SSR) і статичне веб-генерацію (SSG), що робить його ідеальним вибором для створення ефективних і швидких клієнтських додатків.
	Використання TypeScript дозволяє збільшити надійність і зручність розробки, завдяки сильній типізації і можливості виявлення помилок на етапі компіляції. Це особливо корисно для великих проектів і командної розробки, де важлива чітка структура коду і передбачуваність взаємодії між компонентами.
	Next.js надає можливість ефективно використовувати різноманітні функціональні можливості, такі як автоматичне кешування, підтримка динамічної маршрутизації, попереднє завантаження сторінок (prefetching), що сприяє поліпшенню швидкодії додатків і зручності користувачів.
	










ВИСНОВКИ 

	В рамках курсового проекту було розроблено комплексну систему для аналізу зон збуту їжі, що включає в себе серверну частину, IoT-частину і клієнтський інтерфейс. Серверна частина системи була реалізована за допомогою фреймворка Nest.js, з використанням TypeScript для підвищення ефективності і стабільності коду. Була налаштована інтеграція з базою даних PostgreSQL для зберігання даних користувачів, продажів, аналітики та інших важливих аспектів системи. IoT-частина проекту була реалізована з використанням Raspberry Pi, де були налаштовані сенсори RFID для відстеження залишків продуктів і температурний датчик для моніторингу температури у точках продажу. Дані з цих сенсорів збиралися та надсилалися до серверної частини через REST API для подальшого аналізу та обробки. Клієнтський інтерфейс був створений за допомогою фреймворка Next.js, що підтримує SSR і SSG, що забезпечує швидкий відгук і високу продуктивність. Використання TypeScript у клієнтській частині дозволило зменшити кількість помилок і полегшити розробку завдяки сильній типізації і підтримці сучасних функціональних можливостей. Всі частини проекту були інтегровані в єдину систему, що забезпечує користувачам можливість аналізувати дані про продажі, відстежувати залишки продуктів і отримувати важливі повідомлення про події через зручний інтерфейс.







ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

Про Tableau: https://www.tableau.com
Документація Next.js: https://create.t3.gg/uk/usage/next-js
Документація Nest.js: https://foxminded.ua/ru/nest-js/
GitHub репозитроій проекту. URL: https://github.com/NureHalushkaMaksym/apzkr-pzpi-21-4-halushka-maksym
Демонстрація тестування розробленої програмної системи: https://youtu.be/iFl7Tr3L29I
Документація Raspberry Pi: https://www.raspberrypi.com
















ДОДАТОК А 
Код програми серверної частини
A.1 Головний файл серверної частини
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';


async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors({ origin: 'http://localhost:3001', credentials: true });


  app.setGlobalPrefix('api');


  const config = new DocumentBuilder()
    .setTitle('Програмна система для аналізу зон збуту їжі')
    .setDescription('API for managing food sales')
    .setVersion('1.0')
    .addBearerAuth()
    .build();


  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);


  await app.listen(3000);
}
bootstrap();


А.2 Код, який відповідає за резервній копії баз даних

	import { Controller, Get, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';
import * as path from 'path';


@Controller('api/backup')
export class BackupController {
  @Get('download')
  async downloadBackup(@Res() res: Response) {
   
    res.sendFile(filePath, (err) => {
      if (err) {
        console.error('Failed to send file:', err.message);
        res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({ message: 'Failed to send file', error: err.message });
      }
    });
  }
}


import { Module } from '@nestjs/common';
import { BackupController } from './backup.controller';
import { BackupService } from './backup.service';


@Module({
  controllers: [BackupController],
  providers: [BackupService],
})
export class BackupModule {}

import { Injectable } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';


const execPromise = promisify(exec);


@Injectable()
export class BackupService {
  private readonly backupDir = path.resolve('C:', 'Users', 'maxha', 'backup');


  constructor() {
    if (!fs.existsSync(this.backupDir)) {
      fs.mkdirSync(this.backupDir, { recursive: true });
    }
  }


  async createBackup(): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFile = path.join(this.backupDir, `backup-${timestamp}.sql`);
    console.log(`Creating backup at: ${backupFile}`);


    try {
      await execPromise(`pg_dump -U postgres -F c -b -v -f "${backupFile}" my_database`);
      console.log(`Backup created at: ${backupFile}`);
      return backupFile;
    } catch (error) {
      console.error('Backup creation failed:', error.message);
      throw new Error('Backup failed');
    }
  }


  async downloadBackup(filePath: string): Promise<Buffer> {
    console.log(`Downloading backup from: ${filePath}`);
    if (!fs.existsSync(filePath)) {
      throw new Error('File does not exist');
    }


    try {
      return fs.promises.readFile(filePath);
    } catch (error) {
      console.error('File read failed:', error.message);
      throw new Error('File read failed');
    }
  }


  async getLatestBackupFile(): Promise<string> {
    const files = await fs.promises.readdir(this.backupDir);
    if (files.length === 0) {
      throw new Error('No backup files found');
    }


    const sortedFiles = files
      .map(file => ({
        file,
        stats: fs.statSync(path.join(this.backupDir, file)),
      }))
      .sort((a, b) => b.stats.mtimeMs - a.stats.mtimeMs);


    const latestFile = path.join(this.backupDir, sortedFiles[0].file);
    console.log(`Latest backup file: ${latestFile}`);
    return latestFile;
  }
}

А.3 Код, який відповідає за всі модулі

import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';
import { SalesModule } from './sales/sales.module';
import { NotificationsModule } from './notifications/notifications.module';
import { RolesModule } from './roles/roles.module';
import { PermissionsModule } from './permissions/permissions.module';
import { HealthModule } from './health/health.module';
import { AuthModule } from './auth/auth.module';
import { MarketAnalysisModule } from './market_analysis/market_analysis.module';
import { BackupModule } from './backup/backup.module';
import { Users } from './users/user.entity';
import { Role } from './roles/role.entity';
import { Permission } from './permissions/permission.entity';
import { Sale } from './sales/sale.entity';
import { MarketAnalysis } from './market_analysis/market_analysis.entity';
import { Notification } from './notifications/notification.entity';
import { Log } from './logs/log.entity';
import configuration from './config';


@Module({
  imports: [
    ConfigModule.forRoot({
      load: [configuration],
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get<string>('database.host'),
        port: configService.get<number>('database.port'),
        username: configService.get<string>('database.username'),
        password: configService.get<string>('database.password'),
        database: configService.get<string>('database.name'),
        entities: [Users, Role, Permission, Sale, MarketAnalysis, Notification, Log],
        migrations: ['dist/migrations/*{.ts,.js}'],
        cli: {
          migrationsDir: 'src/migrations',
        },
        synchronize: false,
      }),
      inject: [ConfigService],
    }),
    UsersModule,
    SalesModule,
    NotificationsModule,
    RolesModule,
    PermissionsModule,
    HealthModule,
    AuthModule,
    MarketAnalysisModule,
    BackupModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}












































ДОДАТОК Б 
Код програми клієнтської частини

Б.1 Код головної сторінки


"use client";


import React, { ReactNode } from 'react';
import { AppBar, Toolbar, Typography, Button } from '@mui/material';
import Link from 'next/link';
import { AuthProvider } from './contexts/AuthContext';


interface RootLayoutProps {
  children: ReactNode;
}


const Header: React.FC = () => {
  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" style={{ flexGrow: 1 }}>
          Food Sales Zones
        </Typography>
        <Button color="inherit" component={Link} href="/sign-in">Sign In</Button>
        <Button color="inherit" component={Link} href="/sign-up">Sign Up</Button>
      </Toolbar>
    </AppBar>
  );
};


const RootLayout: React.FC<RootLayoutProps> = ({ children }) => {
  return (
    <html lang="en">
      <head>
        <title>Food Sales Zones</title>
        <meta name="description" content="Welcome to the software system Food Sales Zones" />
      </head>
      <body>
        <AuthProvider>
          <Header />
          {children}
        </AuthProvider>
      </body>
    </html>
  );
};


export default RootLayout;

Б.2 Код завантаження бази даних


"use client";


import React from 'react';
import { Container, Button, Typography } from '@mui/material';


const BackupPage: React.FC = () => {
  const handleDownloadBackup = async () => {
    try {
      const response = await fetch('http://localhost:3000/api/backup/download');
      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'bd.sql';
        a.click();
        window.URL.revokeObjectURL(url);
      } else {
        const errorText = await response.text();
        alert(`Failed to download backup: ${errorText}`);
      }
    } catch (error) {
      alert(`Failed to download backup: ${error.message}`);
    }
  };


  return (
    <Container>
      <Typography variant="h4">Backup Page</Typography>
      <Button variant="contained" color="primary" onClick={handleDownloadBackup}>
        Download Backup
      </Button>
    </Container>
  );
};


export default BackupPage;






























ДОДАТОК В 
Код програми IoT пристрою
В.1 Головний код смарт пристрою

const express = require('express');
const axios = require('axios');
const app = express();
const port = 3002;


const getProductsFromApi = async () => {
  try {
    const response = await axios.get('http://localhost:3000/api/sales/view-product-list');
    return response.data;
  } catch (err) {
    console.error('Failed to fetch products from API:', err.message);
    return [];
  }
};




const getRandomTemperature = () => Math.floor(Math.random() * (30 - 15 + 1)) + 15;




const getRandomDemandForProducts = (products) => {
  return products.map(product => ({
    id: product.id,
    name: product.name,
    stock: Math.floor(Math.random() * 100),
    demand: Math.floor(Math.random() * 100)
  }));
};


app.get('/api/products', async (req, res) => {
  try {
    const products = await getProductsFromApi();


    const productsWithStockAndDemand = getRandomDemandForProducts(products);
    res.json(productsWithStockAndDemand);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});




app.get('/api/temperature', (req, res) => {
  res.json({ temperature: getRandomTemperature() });
});




app.get('/api/demand', async (req, res) => {
  try {


    const products = await getProductsFromApi();


    const demand = getRandomDemandForProducts(products);
    res.json(demand);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});


app.listen(port, () => {
  console.log(`IoT simulator listening at http://localhost:${port}`);
});
